# Практичний посібник: Інтеграція FFMPEG у Python-скрипти

Цей документ узагальнює досвід, отриманий під час налагодження виклику `ffmpeg` з фонового процесу (RQ worker). Він описує поширені проблеми та надійний метод їх вирішення.

---

## 1. Проблема: "Зависання" FFMPEG при запуску зі скрипта

Основна проблема полягала в тому, що `ffmpeg` успішно працював при запуску вручну з терміналу, але "зависав" або мовчки завершувався невдачею при запуску з Python-скрипта, особливо з фонового воркера.

**Симптоми:**
-   Процес Python, який викликав `ffmpeg`, не завершувався і не видавав помилок.
-   Не створювався або створювався неповний вихідний файл.
-   Відсутність значного навантаження на процесор чи пам'ять, що вказувало на те, що `ffmpeg` навіть не починав активну роботу.

**Першопричина:**
Проблема полягає у взаємодії процесів. `ffmpeg` за замовчуванням є інтерактивною програмою. При запуску він може перевіряти стандартний потік вводу (`stdin`), очікуючи на можливі команди (наприклад, `q` для виходу).

Коли `ffmpeg` запускається з фонового процесу (наприклад, RQ worker), цей процес не має підключеного терміналу, і його `stdin` знаходиться в невизначеному стані. Це призводить до "зависання": `ffmpeg` чекає на `stdin`, який ніколи не буде готовий.

---

## 2. Помилкові шляхи та їхні недоліки

Під час діагностики було спробовано кілька методів, які не дали бажаного результату:

1.  **Простий виклик `subprocess.run`:** Не працював через проблему зі `stdin` та потенційні проблеми з передачею імен файлів з пробілами.
2.  **Виклик через `shell=True`:** Хоча цей метод імітує ручний запуск і може вирішити проблему з іменами файлів, він не вирішує проблему очікування `stdin` і вважається менш безпечним.
3.  **Використання бібліотеки `ffmpeg-python` без параметрів:** Це найчистіший підхід, але він також "зависав", оскільки за замовчуванням не вирішував проблему зі `stdin`.

---

## 3. Надійне рішення: `ffmpeg-python` з прапорцем `-nostdin`

Фінальний метод, який виявився надійним і стабільним, поєднує зручність бібліотеки `ffmpeg-python` та ключовий прапорець командного рядка.

**Ключові компоненти рішення:**

1.  **Використання бібліотеки `ffmpeg-python`:** Вона надає зручний та "пітонічний" інтерфейс для побудови складних команд `ffmpeg`.
2.  **Прапорець `-nostdin`:** Це найважливіша частина. Цей прапорець явно наказує `ffmpeg` **не намагатися** читати дані зі стандартного потоку вводу. Це усуває першопричину "зависання" при запуску в неінтерактивному середовищі.
3.  **Правильний синтаксис:** Важливо правильно передати цей глобальний прапорець бібліотеці.

### Приклад робочого коду

Ось фінальний, перевірений код з файлу `src/core/media_processor.py`:

```python
import ffmpeg
# ... інші імпорти

# ...

try:
    # 1. Побудова ланцюжка операцій за допомогою ffmpeg-python
    # 2. Додавання глобального прапорця -nostdin через параметр `cmd` у функції .run()
    # 3. Використання .overwrite_output() для коректного перезапису файлів
    (
        ffmpeg
        .input(original_file_name)
        .output(wav_file_name, ac=1, ar=16000) # ac=моно, ar=частота
        .overwrite_output()
        .run(cmd=['ffmpeg', '-nostdin'], capture_stdout=True, capture_stderr=True)
    )
    logger.info(f"[{firestore_ref}] Conversion successful")

except ffmpeg.Error as e:
    # Якщо ffmpeg поверне помилку, вона буде зловлена і залогована
    logger.error(f"[{firestore_ref}] FFMPEG Error: {e.stderr.decode()}", exc_info=True)
    raise
```

**Пояснення синтаксису `.run(cmd=['ffmpeg', '-nostdin'])`:**
Параметр `cmd` у функції `.run()` дозволяє перевизначити саму команду запуску. Вказуючи `['ffmpeg', '-nostdin']`, це змушує бібліотеку поставити прапорець `-nostdin` на самий початок команди, що робить його глобальним і вирішує проблему.

Цей підхід є надійним, безпечним і рекомендованим для використання `ffmpeg` у будь-яких автоматизованих Python-скриптах, особливо у фонових задачах та чергах.
