# Архітектура Системи

Цей документ описує архітектуру API-сервісу для діаризації та транскрипції медіафайлів.

---

## 1. Компоненти Системи

Система побудована на мікросервісній архітектурі та складається з наступних ключових компонентів:

1.  **API-сервер (Flask):**
    -   Приймає `POST` запити на ендпоінт `/api/transcribe`.
    -   Валідує вхідні дані (`media_url`, `firestore_ref` і т.д.).
    -   Негайно ставить "важке" завдання з обробки медіа в чергу Redis.
    -   Миттєво відповідає клієнту, не блокуючи з'єднання.
    -   Також надає ендпоінт `/api/health` для моніторингу стану черги.

2.  **Черга завдань (Redis + RQ):**
    -   Використовується для керування асинхронними завданнями.
    -   Дозволяє API-серверу залишатися швидким та відзивчивим, переносячи тривалі операції у фоновий режим.

3.  **Фоновий Воркер (RQ Worker):**
    -   Окремий процес, який запускається разом з основним додатком.
    -   Постійно слухає чергу Redis.
    -   Коли з'являється нове завдання, воркер забирає його і послідовно виконує всі етапи обробки.

4.  **Сервіси Google Cloud & Firebase:**
    -   **Firebase Firestore:** Використовується як база даних для зберігання статусів обробки (`QUEUED`, `DOWNLOADING`, `PROCESSING`, `DONE`, `ERROR`) та фінального результату (транскрипту, метаданих).
    -   **Google Cloud Storage:** Використовується для тимчасового зберігання довгих аудіосегментів (> 60 секунд) для їх асинхронної транскрипції.

---

## 2. Життєвий Цикл Запиту

1.  **Ініціація:** Клієнт надсилає `POST` запит на `/api/transcribe` з URL медіафайлу та посиланням на документ у Firestore.

2.  **Постановка в чергу:**
    -   Flask-сервер отримує запит.
    -   Оновлює документ у Firestore, встановлюючи `status: 'QUEUED'` та час `received_at`.
    -   Створює завдання `process_media_task` і додає його в чергу Redis.
    -   Відповідає клієнту `{"message": "Processing started"}`.

3.  **Виконання у Воркері:**
    -   RQ воркер у фоновому режимі забирає завдання з черги.
    -   **Завантаження:**
        -   Оновлює статус у Firestore на `DOWNLOADING`.
        -   Завантажує медіафайл за вказаним URL.
    -   **Конвертація:**
        -   Конвертує завантажений файл у формат WAV (`mono`, `16000 Hz`) за допомогою **FFMPEG**. Використовується бібліотека `ffmpeg-python` з прапорцем `-nostdin` для стабільної роботи у фоновому режимі.
    -   **Діаризація:**
        -   Оновлює статус на `PROCESSING`.
        -   Застосовує модель `pyannote/speaker-diarization` для розбиття аудіо на сегменти за спікерами.
    -   **Транскрипція (Паралельна):**
        -   Усі отримані аудіосегменти відправляються на транскрипцію до Google Cloud Speech-to-Text **одночасно** за допомогою `ThreadPoolExecutor`.
        -   **Обробка довгих сегментів:** Якщо сегмент довший за 60 секунд, він завантажується в Google Cloud Storage і транскрибується за допомогою асинхронного API (`long_running_recognize`).
    -   **Завершення:**
        -   Результати транскрипції збираються та сортуються.
        -   Документ у Firestore оновлюється: `status: 'DONE'`, додається фінальний транскрипт, метадані та час `finished_at`.
    -   **Обробка помилок:** Якщо на будь-якому етапі виникає помилка, статус змінюється на `ERROR`, записується повідомлення про помилку та час `finished_at`.
    -   **Очищення:** Усі тимчасові файли (завантажене медіа, WAV, аудіосегменти) видаляються з локального сховища сервера.

---

## 3. Запуск Додатку

Додаток запускається як Python-модуль з кореневої директорії. Це критично важливо для правильної роботи відносних імпортів між файлами проєкту.

```bash
python3 -m src.app
```

При старті `src/app.py` автоматично запускає процес воркера за допомогою модуля `multiprocessing`.
